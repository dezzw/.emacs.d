From ad87e96e08971897e04fe1b43c65d749a424eba1 Mon Sep 17 00:00:00 2001
From: ksqsf <i@ksqsf.moe>
Date: Wed, 31 Jul 2024 02:57:19 +0200
Subject: [PATCH 1/2] Add smooth cursor animation

---
 src/nsterm.h |  1 +
 src/nsterm.m | 66 ++++++++++++++++++++++++----------------------------
 2 files changed, 31 insertions(+), 36 deletions(-)

diff --git a/src/nsterm.h b/src/nsterm.h
index 3a713f8e8c94..77196865a879 100644
--- a/src/nsterm.h
+++ b/src/nsterm.h
@@ -485,6 +485,7 @@ enum ns_return_frame_mode
   struct frame *emacsframe;
   int scrollbarsNeedingUpdate;
   NSRect ns_userRect;
+  CALayer *cursor_layer;
 }
 
 /* AppKit-side interface */
diff --git a/src/nsterm.m b/src/nsterm.m
index d25f216edd49..7d80b38d01e3 100644
--- a/src/nsterm.m
+++ b/src/nsterm.m
@@ -71,6 +71,7 @@ Updated by Christian Limpach (chris@nice.ch)
 #include "macfont.h"
 #include <Carbon/Carbon.h>
 #include <IOSurface/IOSurface.h>
+#include <QuartzCore/QuartzCore.h>
 #endif
 
 static EmacsMenu *dockMenu;
@@ -3064,6 +3065,9 @@ Note that CURSOR_WIDTH is meaningful only for (h)bar cursors.
       return;
     }
 
+  if (!active_p)
+    return;
+
   get_phys_cursor_geometry (w, glyph_row, phys_cursor_glyph, &fx, &fy, &h);
 
   /* The above get_phys_cursor_geometry call set w->phys_cursor_width
@@ -3101,44 +3105,23 @@ Note that CURSOR_WIDTH is meaningful only for (h)bar cursors.
   /* Prevent the cursor from being drawn outside the text area.  */
   r = NSIntersectionRect (r, ns_row_rect (w, glyph_row, TEXT_AREA));
 
-  ns_focus (f, NULL, 0);
-
-  NSGraphicsContext *ctx = [NSGraphicsContext currentContext];
-  [ctx saveGraphicsState];
-#ifdef NS_IMPL_GNUSTEP
-  GSRectClipList (ctx, &r, 1);
-#else
-  NSRectClip (r);
-#endif
-
-  [FRAME_CURSOR_COLOR (f) set];
-
-  switch (cursor_type)
+  /* the CA cursor doesn't need a drawing context: we directly set its color. */
+  EmacsView *view = FRAME_NS_VIEW (f);
+  CALayer *cursor_layer = view->cursor_layer;
+  if (! cursor_layer)
+    return;
+  r.origin.y = [view bounds].size.height - r.size.height - r.origin.y;
+  [CATransaction begin];
+  [CATransaction setAnimationDuration:0.1];
+  cursor_layer.backgroundColor = FRAME_CURSOR_COLOR (f).CGColor;
+  if (cursor_type == BAR_CURSOR)
     {
-    case DEFAULT_CURSOR:
-    case NO_CURSOR:
-      break;
-    case FILLED_BOX_CURSOR:
-      /* The call to draw_phys_cursor_glyph can end up undoing the
-	 ns_focus, so unfocus here and regain focus later.  */
-      [ctx restoreGraphicsState];
-      ns_unfocus (f);
-      draw_phys_cursor_glyph (w, glyph_row, DRAW_CURSOR);
-      ns_focus (f, &r, 1);
-      break;
-    case HOLLOW_BOX_CURSOR:
-      /* This works like it does in PostScript, not X Windows.  */
-      [NSBezierPath strokeRect: NSInsetRect (r, 0.5, 0.5)];
-      [ctx restoreGraphicsState];
-      break;
-    case HBAR_CURSOR:
-    case BAR_CURSOR:
-      NSRectFill (r);
-      [ctx restoreGraphicsState];
-      break;
+      cursor_glyph = get_phys_cursor_glyph (w);
+      if ((cursor_glyph->resolved_level & 1) != 0)
+        r.origin.x += cursor_glyph->pixel_width - r.size.width;
     }
-
-  ns_unfocus (f);
+  cursor_layer.frame = r;
+  [CATransaction commit];
 }
 
 
@@ -9234,6 +9217,17 @@ - (instancetype) initWithEmacsFrame: (struct frame *) f
       [[self contentView] addSubview:view];
       [self makeFirstResponder:view];
 
+      /* Overlay a canvas view on top of EmacsView.  */
+      NSView *canvasView = [[NSView alloc] initWithFrame:view.bounds];
+      canvasView.wantsLayer = YES;
+      canvasView.autoresizingMask = NSViewWidthSizable | NSViewHeightSizable;
+      [view addSubview:canvasView positioned:NSWindowAbove relativeTo:nil];
+
+      /* Create a cursor layer on the canvas.  */
+      view->cursor_layer = [CALayer layer];
+      [canvasView.layer addSublayer: view->cursor_layer];
+      view->cursor_layer.frame = CGRectMake(0, 0, 0, 0);
+
 #if !defined (NS_IMPL_COCOA) || MAC_OS_X_VERSION_MIN_REQUIRED <= 1090
 #if MAC_OS_X_VERSION_MAX_ALLOWED > 1090
       if ([self respondsToSelector: @selector(useOptimizedDrawing:)])

From 3ae21e92b764c59f90becce7cb92975fe6c4e859 Mon Sep 17 00:00:00 2001
From: Mingkai Dong <mk@dong.mk>
Date: Tue, 8 Apr 2025 17:45:50 +0800
Subject: [PATCH 2/2] Add smooth cursor animation for more cursor styles

---
 lisp/term/ns-win.el |  7 ++++
 src/nsterm.m        | 98 +++++++++++++++++++++++++++++++++++++--------
 2 files changed, 89 insertions(+), 16 deletions(-)

diff --git a/lisp/term/ns-win.el b/lisp/term/ns-win.el
index 2a29457133e1..3a9ebab5e827 100644
--- a/lisp/term/ns-win.el
+++ b/lisp/term/ns-win.el
@@ -65,6 +65,13 @@
 ;; nsterm.m.
 (defvar ns-input-file)
 
+(defcustom ns-cursor-animation-duration 0.1
+  "Duration in seconds for cursor animation on macOS.
+This controls how long the cursor animation takes when changing position or style.
+A value of 0 disables animation."
+  :type 'number
+  :group 'ns)
+
 (defun ns-handle-nxopen (_switch &optional temp)
   (setq unread-command-events (append unread-command-events
                                       (if temp '(ns-open-temp-file)
diff --git a/src/nsterm.m b/src/nsterm.m
index 7d80b38d01e3..5d908d84a86c 100644
--- a/src/nsterm.m
+++ b/src/nsterm.m
@@ -44,6 +44,7 @@ Updated by Christian Limpach (chris@nice.ch)
 
 #include "lisp.h"
 #include "blockinput.h"
+#include "dispextern.h"
 #include "sysselect.h"
 #include "nsterm.h"
 #include "systime.h"
@@ -3017,6 +3018,12 @@ Hide the window (X11 semantics)
   ns_unfocus (f);
 }
 
+static double
+ns_get_cursor_animation_duration (void)
+{
+  Lisp_Object duration = Fsymbol_value (intern_c_string ("ns-cursor-animation-duration"));
+  return NUMBERP (duration) ? XFLOATINT (duration) : 0.1;
+}
 
 static void
 ns_draw_window_cursor (struct window *w, struct glyph_row *glyph_row,
@@ -3065,9 +3072,6 @@ Note that CURSOR_WIDTH is meaningful only for (h)bar cursors.
       return;
     }
 
-  if (!active_p)
-    return;
-
   get_phys_cursor_geometry (w, glyph_row, phys_cursor_glyph, &fx, &fy, &h);
 
   /* The above get_phys_cursor_geometry call set w->phys_cursor_width
@@ -3105,23 +3109,84 @@ Note that CURSOR_WIDTH is meaningful only for (h)bar cursors.
   /* Prevent the cursor from being drawn outside the text area.  */
   r = NSIntersectionRect (r, ns_row_rect (w, glyph_row, TEXT_AREA));
 
-  /* the CA cursor doesn't need a drawing context: we directly set its color. */
+  /* The original Emacs uses the following ctx-related stuff to draw
+     the cursor. Here we use the CA layer directly if possible. */
   EmacsView *view = FRAME_NS_VIEW (f);
   CALayer *cursor_layer = view->cursor_layer;
-  if (! cursor_layer)
-    return;
-  r.origin.y = [view bounds].size.height - r.size.height - r.origin.y;
-  [CATransaction begin];
-  [CATransaction setAnimationDuration:0.1];
-  cursor_layer.backgroundColor = FRAME_CURSOR_COLOR (f).CGColor;
-  if (cursor_type == BAR_CURSOR)
+
+  if (active_p && cursor_layer) {
+    NSRect r2 = r;
+    r2.origin.y = [view bounds].size.height - r2.size.height - r2.origin.y;
+    cursor_glyph = get_phys_cursor_glyph (w);
+    if ((cursor_glyph->resolved_level & 1) != 0)
+      r2.origin.x += cursor_glyph->pixel_width - r2.size.width;
+
+    switch (cursor_type)
+      {
+      case DEFAULT_CURSOR:
+      case NO_CURSOR:
+        /* Make the layer invisible. */
+        cursor_layer.opacity = 0.0;
+        cursor_layer.backgroundColor = nil;
+        cursor_layer.frame = r2;
+        break;
+      case FILLED_BOX_CURSOR:
+      case HOLLOW_BOX_CURSOR:
+      case HBAR_CURSOR:
+      case BAR_CURSOR:
+        [CATransaction begin];
+        [CATransaction setAnimationDuration:ns_get_cursor_animation_duration ()];
+        [CATransaction setCompletionBlock:^{
+              cursor_layer.backgroundColor = nil; /* hide after animation */
+              cursor_layer.opacity = 0.0;
+        }];
+        cursor_layer.backgroundColor = FRAME_CURSOR_COLOR (f).CGColor;
+        cursor_layer.opacity = 1.0;
+        cursor_layer.frame = r2;
+        [CATransaction commit];
+        break;
+    }
+  }
+  /* Below is the original Emacs drawing code for the cursor. */
+
+  ns_focus (f, NULL, 0);
+
+  NSGraphicsContext *ctx = [NSGraphicsContext currentContext];
+  [ctx saveGraphicsState];
+#ifdef NS_IMPL_GNUSTEP
+  GSRectClipList (ctx, &r, 1);
+#else
+  NSRectClip (r);
+#endif
+
+  [FRAME_CURSOR_COLOR (f) set];
+
+  switch (cursor_type)
     {
-      cursor_glyph = get_phys_cursor_glyph (w);
-      if ((cursor_glyph->resolved_level & 1) != 0)
-        r.origin.x += cursor_glyph->pixel_width - r.size.width;
+    case DEFAULT_CURSOR:
+    case NO_CURSOR:
+      break;
+    case FILLED_BOX_CURSOR:
+      /* The call to draw_phys_cursor_glyph can end up undoing the
+	 ns_focus, so unfocus here and regain focus later.  */
+      [ctx restoreGraphicsState];
+      ns_unfocus (f);
+      draw_phys_cursor_glyph (w, glyph_row, DRAW_CURSOR);
+      ns_focus (f, &r, 1);
+      break;
+    case HOLLOW_BOX_CURSOR:
+      /* This works like it does in PostScript, not X Windows.  */
+      [NSBezierPath strokeRect: NSInsetRect (r, 0.5, 0.5)];
+      [ctx restoreGraphicsState];
+      break;
+    case HBAR_CURSOR:
+    case BAR_CURSOR:
+      NSRectFill (r);
+      [ctx restoreGraphicsState];
+      break;
     }
-  cursor_layer.frame = r;
-  [CATransaction commit];
+
+  ns_unfocus (f);
 }
 
 
@@ -9228,6 +9293,7 @@ - (instancetype) initWithEmacsFrame: (struct frame *) f
       [canvasView.layer addSublayer: view->cursor_layer];
       view->cursor_layer.frame = CGRectMake(0, 0, 0, 0);
 
+
 #if !defined (NS_IMPL_COCOA) || MAC_OS_X_VERSION_MIN_REQUIRED <= 1090
 #if MAC_OS_X_VERSION_MAX_ALLOWED > 1090
       if ([self respondsToSelector: @selector(useOptimizedDrawing:)])
